# depots 详细设计

## 概要

数据驿站是数据的临时汇聚地，主要负责全网数据的协调和沟通：根据目标数据的紧缺性感知和自身的存储策略，实时调整自己的存储集。

驿站内部需要整合实际的数据服务，比如区块查询或存档检索等。当然，整合的服务实际上也可以是一种纯粹的服务，比如聊天，数据ID在这里只是一个入口标识。

数据服务的收益地址通常由服务自身发送，驿站只是一个联络者，根据请求的ID提供目标的连系信息而已。


### 数据查询

应用对需要的数据创建询问消息包，其中包含目标数据的全网唯一性**数据标识**，以及起始跳数（可非零）。跳数记录用于数据的紧缺性感知。

应用向连接的驿站节点发送询问包，请求查询数据。


#### 检索

驿站解析询问包数据标识，获取数据类别和ID，按类别查询ID索引集（布隆过滤器）。

1. 如果目标不存在：

- 询问包跳数加一后即刻**转播**请求。
- 触发数据存储策略，根据结果决定是否请求目标数据的补充存储。

2. 如果目标存在：

- 向内部数据服务查询确认，确认存在，创建连系信息回复包，递送给来源节点。
- 如果内部服务无目标，则同前转播，以及可能的补存措施。

> **注记：**
> 在驿站层面设置索引集先进行存在性判断，是为了询问包的快速广播，优化效率。
> 索引集可能采用布隆过滤器：有*可能*没有，但没有*肯定*没有。


#### 储备

如果内部服务未找到数据，或者根据数据的紧缺性和存储策略需要存储数据，则驿站会自己发起询问，请求目标数据。

> **注：**
> 内部服务只负责存储和检索，这样便于集成现有的任意数据库方案。


### 数据上传

应用端创建的初始数据需要进入数据网络，因此需要一个把自身数据上传的机制。


#### 探测

应用端首先向网络发送一个目标数据的**探测**包，这是一个简单的请求，无需驿站返回真实的数据。


#### 上传

这个探测会触发驿站的数据紧缺性判定。由此，驿站可能主动请求该数据。此时应用端即可充当数据源节点，将数据上传，完成初始的数据上网。



## 数据请求流程

> **前提：**
> 节点需要知道自身NAT的类型，这借助于公共STUN（findings）服务。


### 四个阶段

1. **广播询问**：目标数据的请求一对多逐级转播扩散。**注**：自动适时终止。
2. **传递回复**：应答包原线路回传，多对一逐层消减。**注**：可取2-3个最先收到的响应回传。
3. **请求确认**：应用端和数据提供者直接连系，数据请求确认。
4. **数据传递**：与数据提供节点建立连接，获取数据（可能分片多点传输）。


#### 惰性响应

数据询问在网络中的转播遵循简单的惰性响应原则：*有即终止，无则转播*。

即收到询问的驿站节点会对数据进行检查，如果发现自身拥有数据，则停止转播，发送回复。如果没有目标数据，则转播该询问。

驿站仅对单个目标数据的哈希执行检查和响应，这个单个的数据可能是一个完整的数据，也可能只是某数据的一个分片（如果询问的只是这个分片的话）。

> **注：**
> 如果节点只是拥有目标数据的部分片段，是否终止转播，由节点自己决定。
> 通常，如果节点拥有大部分片段数据（80%+），会不再转播，否则回复的同时也会续传询问。


### 1. 广播询问

客户端构造数据询问包，向相连的驿站节点发送询问请求。出于隐私保护，数据包不附带询问者的身份或位置信息。


#### 询问包

代码格式约定

```go
> `(n)` 占用字节数，即 n bytes。
> `[n]` 占用比特位数，即 n bits。
```

下面的字节数和比特位数只是一个逻辑值，具体的占用与通讯协议及数据包格式有关。

> **注：**
> 代码实现可能采用 ProtoBuf 数据封装协议。

```go
(4)     Ver：版本号。
(8)     ID： 标识本次询问，用于回复包对应源请求。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[4]     跳数累计：上限值15，可以是非零起跳。
[4]     公钥算法：默认 X25519。最多支持15种。
(32+)   公钥数据：用于回复包加密连系信息。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[4]     NAT 层级：
        1) `Pub/FullC`：可直连类型，含通过 UPnP 直接映射到公网。
        2) `RC`：受限圆锥型节点（Restricted Cone）。
        3) `P-RC`：端口受限圆锥型节点（Port Restricted Cone）。
        4) `Sym`：NAT对称型节点（Symmetric NAT）。
[4]     （未用）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(1)     数据类别：
        主要用于隔离不同数据采用的不同服务。
        当类别为隐秘的用户定制区时，依靠后续的数据索引区分，可能为服务而非数据。
        0 ~ 0x7F 系统保留区：
        - 存档类：只是简单的检索获取。默认类别。
        - 区块链：提供交易信息服务，比如检索一笔交易或某个区块。
        - ……
        0x80 ~ 0xFF 用户定制区：
        - 任意类型，由应用私下自行约定，隐秘性。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(1+n)   数据索引：
        通常为数据内容的哈希摘要，但也可由用户自己定义和解释（如包含子类）。
        这与上面的数据类别相关。
(4)     数据大小：
        按字节计数的数据尺寸，可选。
        零值表示忽略、未知或无定义（比如提供的是一个服务）。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

询问包为明文未加密，但节点之间为加密通讯，避免第三方窥探。


#### 转播包

节点检查自身是否拥有目标数据。

- **无**：标记该查询，将询问包内*跳数*加一后转播，延续询问……
- **有**：检查彼此NAT层级并创建回复。若因NAT限制两端无法通讯，则视同没有数据。

在询问包的转播扩散过程中，中转节点会记住查询来源，因为回复包需要按原路径逆向返回。


### 2. 传递回复

如果节点拥有目标数据，构建回复包返回。

信息返回按原路径逆向回传，这可以让逐级扩散的询问信息变为逐级收缩，最终恢复为正常的流量。**注**：这也是让询问者可以不必公开自己地址的原因。

如果数据源是受限节点（`RC|P-RC|Sym`），此时只能使用UDP协议，回复包附带打洞协助相关信息：

- 自己的NAT层级。**注**：实际上非必需。
- 自己连接的Findings公网节点。
- 自己连接Findings公网节点的类别（`kind:name`）。

> **注：**
> 任何一方为`Sym`受限节点时，另一方必须为公网类（`Pub/FullC`）节点。
> 数据源节点发送打洞信息前，应确保自己已经连接了共享的Findings公网节点。


#### 回复包

```go
(4)     Ver：版本号。
(8)     询问ID：原询问包ID，用于对应请求源。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(32+)   公钥数据：
        数据源的公钥，用于询问端构造共享密钥。算法与询问包相同。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
注：以下信息用共享密钥加密
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[4]     跳数累计：
        到数据源时的跳数，加密避免修改，可用于距离评估。
[4]     NAT 层级：
        数据源节点的信息，仅UDP适用。可选
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(n)     - 协议：
          顶层封装名： websocket|dtls，或 tcp|udp（未封装）
          如果为UDP类，则上面NAT层级信息有效。
        - 数据地址：
          与协议对应，IP:Port。
        - 打洞辅助：
          Findings节点地址、数据节点类名（kind:name）。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

回复包部分数据加密，长度不定。

> **注：**
> 如果协议是普通TCP或UDP，双方应当使用共享密钥来加密传输的数据。


### 3. 请求确认

询问者收到回复后，用对方的公钥与自己的私钥构建共享密钥，解密回复包内的连系信息。

采用何种方式与数据源节点连接，有以下几种情况：

- 如果数据源为公网类节点（`Pub/FullC`）。通常会提供TCP类支持，询问者连接请求即可。
- 如果数据源为受限节点（`RC|P-RC|Sym`）。连系信息中包含打洞相关信息，借助于Findings节点定向打洞服务即可。

> **注：**
> 如果数据源为 `Sym` 受限类型，询问者自己必须是 `Pub/FullC` 级别才行。


### 4. 数据传递

与拥有目标数据的节点建立连接后，即可获取所需数据。询问端会向多个连接端发送请求，因此通常也会有多个节点回应。

传递大文档数据时，通常采用类似 BitTorrent 的策略，会对大尺寸数据进行分片。


### 数据探测

**数据探测**主要用于完成数据的紧缺性感知。与数据询问不同，探测无需实际的数据返回，即无需回复。

节点行为：检查目标数据，**有即停止，无则转播**。

当然，作为驿站节点本身，在探测包流经节点的过程中，根据数据的紧缺性判定和自身的存储策略，即可决定自己是否需要存储目标数据。


#### 探测包

```go
(4)     Ver：版本号
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[4]     跳数累计：上限值15。约定：从零起跳
[4]     签名算法：最多可表示15种。
(n)     签名公钥：与上面的算法对应。可用于权威数据心跳节点的识别。
(n)     签名数据：对数据消息的签名结果。
        注：
        签名的目标消息为下面的数据信息：类别+索引+大小。
        整个签名部分为可选。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(1)     数据类别：
        与查询包相同规范。
(1+n)   数据索引：
        通常为数据内容的哈希摘要，但也可由用户自己定义和解释。
        这与上面的数据类别相关。
(4)     数据大小：
        按字节计数的数据尺寸，零值表示未知。可选。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

探测包为明文未加密数据，合计最多 `42+签名数据` 字节长。


### 附：文档ID与数据ID

一个大尺寸数据通常采用分片，然后计算各分片的默克尔校验树汇总成一个根哈希，此即为数据ID。它与从文件本身计算的哈希摘要（文档ID）不同。

询问请求里的数据索引应当是针对数据ID，即便该索引可能包含内部的结构。文档ID通常仅在本地校验时有用。



## 数据服务

### 档案存储

作为一种最基本的数据服务，基本上适用于任意文档的“保留数据”性质的存档。

该服务没有更多的功能，检索也只是针对一个数据ID。数据ID为内容或分片内容的特定哈希摘要（当前版本采用 `SHA3:256` 算法）。

详细内容可参考项目 [github.com/cxio/archives](https://github.com/cxio/archives)。


### 区块查询

与档案存储服务类似，这也是数据网络最基本的服务，因为数据网络的运行就基于区块链的激励能力。

区块查询有其自身的特点，需要提供尽可能高效的性能，因此一个普通的驿站可能只提供一个区块链的查询服务。

数据索引为一个定制的结构：`[blockchain-name]:[...]`，前面的 `blockchain-name` 和 `:` 分隔为固定格式，后段的 `...` 则由其自己的注册函数解释。

> **注：**
> 区块链的名称由冒号（:）与后面的结构区分，因此区块链名称本身不能包含冒号。

详见项目 [github.com/cxio/blockqs](https://github.com/cxio/blockqs)。


### 其它服务

驿站支持的内置服务是一个泛化的逻辑，即它可以支持任意服务，只需要在数据类别中标识区分即可。

第三方服务也是由其自身负责解释数其据索引，并没有统一的规范。

仅仅通过数据类别来区分不同的服务并不严谨，但这是**泛化**需要付出的代价。驿站只能通过内置服务的错误返回来丢弃不属于本类的请求（它们类别相同）。



## 存储策略

数据网络存储的是所有愿意将其上传至数据网络的任意数据，它是开放性的。逻辑上，这样的数据规模是无限的，因此每一个驿站肯定会有自己的存储选择策略。

目前，存储策略由三项措施来达成：**策略函数**、**白名单**、**黑名单**。


### 策略函数

用一个函数调用来反应存储意愿，函数返回真表示存储，否则忽略。每一个数据类别都对应一个策略集，它们以数据类别的值为目录名（如 `0`、`1` 等），创建在用户的配置目录（`[Home]/.depots/ploys/*`）下。

策略函数接受目标数据的ID和大小，返回一个布尔值，声明为：`func([]byte, int) bool`。通常你只需要定义数据ID的匹配即可，但有时你可能需要特别的选择策略。

支持两种语言编写策略：原生的Go语言，以及小巧的Lua脚本。文件名固定为 `ploy.go` 和 `ploy.lua`，不可更改。


### 白名单与黑名单

有一些数据可能是节点想无条件保留的，这就是白名单的逻辑。白名单的目标ID会用用户配置的随机种子与数据ID执行哈希混淆，因此名单中的ID并不会是原始的数据ID，这是一种隐私性保护措施。

白名单中包含与目标ID的正则匹配式，或者就是目标ID本身。

数据网络鼓励各个节点的无差别随机存储，这对数据在全网的均匀分布有利，但肯定也会有用户不愿意存储某些东西，这就是黑名单的需求。匹配逻辑与白名单相似，都是针对混淆之后的ID。

在优先级上，白名单优于黑名单，如果同一目标ID同时存在于黑名单和白名单中，则白名单有效（黑名单被忽略）。其次，黑名单优于策略函数，如果某一目标已经存在于黑名单中，则不会再执行策略函数。

> **优先级**： 白名单 > 黑名单 > 策略函数


### 附：消息包攻击

如果一个攻击者虚构一个数据的ID发布询问，可能导致存储策略匹配的节点对该虚假数据的请求，这会导致该询问包的增量发布。这可能是一个问题，如果有太多策略匹配的节点的话。

但这也只有一次增量，不会导致指数级增长的消息洪流。

驿站节点应当考虑到这一效应，定制存储策略时不宜匹配过宽。通常，拥有宽泛匹配策略的驿站应是大节点（数据集群），而这样的大节点数量应不至于太多。所以这种攻击的危害可能有限。

> **应对：**
> 如果驿站节点需要补充目标数据，但并不立即执行，这应该能降低攻击的预期（难以评估）。
> 所以驿站补充数据可以采用并不急于求成的态度，有一个随机的延迟可能较好。
